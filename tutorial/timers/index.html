<!DOCTYPE html>
<html lang="en">
  <head>
    

  


  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Repositorio de conocimiento colectivo y canal de coordinación en torno a los ecosistemas Arduino, Raspberry Pi...">
  
  <meta name="author" content="FreeJaus - La Casilla">
  <meta name="generator" content="Hugo 0.36.1" />
  <link rel="apple-touch-icon" sizes="57x57" href="http://freejaus.github.io/ardupi/favicon/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="http://freejaus.github.io/ardupi/favicon/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="http://freejaus.github.io/ardupi/favicon/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="http://freejaus.github.io/ardupi/favicon/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="http://freejaus.github.io/ardupi/favicon/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="http://freejaus.github.io/ardupi/favicon/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="http://freejaus.github.io/ardupi/favicon/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="http://freejaus.github.io/ardupi/favicon/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="http://freejaus.github.io/ardupi/favicon/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="http://freejaus.github.io/ardupi/favicon/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="http://freejaus.github.io/ardupi/favicon/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="http://freejaus.github.io/ardupi/favicon/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="http://freejaus.github.io/ardupi/favicon/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="http://freejaus.github.io/ardupi/favicon/manifest.json">
<link rel="mask-icon" href="http://freejaus.github.io/ardupi/favicon/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="http://freejaus.github.io/ardupi/favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-TileImage" content="/favicon/mstile-144x144.png">
<meta name="msapplication-config" content="/favicon/browserconfig.xml">
<meta name="theme-color" content="#ffffff">
  <title>FreeJaus - Ardupi - Timers</title>
  <meta content="FreeJaus - Ardupi - Timers" property="og:title">
  <meta content="timer" name="keywords">

  <!-- Bootstrap and Font Awesome CSS -->
  
    <link href="http://freejaus.github.io/ardupi/local/css/bootstrap.min.css" rel="stylesheet">
    <link href="http://freejaus.github.io/ardupi/local/css/font-awesome.min.css" rel="stylesheet">
  

  <!-- Custom CSS -->
  <link href="http://freejaus.github.io/ardupi/css/fj-base.css" rel="stylesheet">

  <!-- Custom Fonts -->
  <link href='https://fonts.googleapis.com/css?family=Righteous' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
  <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Kaushan+Script" rel="stylesheet" type="text/css"><link href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic,700italic" rel="stylesheet" type="text/css">
  
  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->

  </head>
  <body>
    Timers
    

<p>Los temporizadores, también llamados timers o timers/counters, son unos periféricos de los que disponen la práctica totalidad de microcontroladores que se emplean para implementar diversas funciones relacionadas con el tiempo o con el contaje. En realidad, estos periféricos son contadores. Cuando lo que están contando es una frecuencia fija derivada del cristal oscilador del microcontrolador, se denominan timers y, cuando lo que están contando es un evento (flanco de subida o flanco de bajada) en una patilla del microcontrolador, se denominan contadores. Si bien el funcionamiento es análogo, en este tutorial nos centraremos en las aplicaciones como temporizador/timer. Dependiendo del microcontrolador tendremos más o menos timers y, dependiendo del tamaño del registro en el que almacenan el contaje, hablaremos de timers de <code>8 bits</code> o de <code>16 bits</code>.</p>

<p>Si bien las explicaciones que siguen a continuación pueden adaptarse a diferentes modelos de placas de desarrollo de Arduino, el código y los registros indicados harán referencia a las placas <a href="http://arduino.cc/en/Main/ArduinoBoardADK">Mega ADK</a> y <a href="http://arduino.cc/en/Main/ArduinoBoardMega2560">Mega 2560</a>. Estas dos placas comparten el microprocesador de <code>8 bits</code> <a href="http://www.atmel.com/dyn/resources/prod_documents/doc2549.PDF">ATmega2560</a> el cual cuenta con dos timers de <code>8 bits</code> (el <code>Timer 0</code> y el <code>Timer 2</code>) y cuatro temporizadores de <code>16 bits</code> (los timers <code>1</code>, <code>3</code>, <code>4</code> y <code>5</code>).</p>

<p>Como hemos dicho, son muchas las ocasiones en las que necesitaremos implementar funciones relacionadas con el tiempo, por lo que Arduino ha desarrollado varias funciones software para las necesidades más usuales:</p>

<ul>
<li><p>para realizar retardos y contaje de tiempo: <a href="http://arduino.cc/en/Reference/Millis"><code>millis()</code></a>, <a href="http://arduino.cc/en/Reference/Micros"><code>micros()</code></a>, <a href="http://arduino.cc/en/Reference/Delay"><code>delay()</code></a> y <a href="http://arduino.cc/en/Reference/DelayMicroseconds"><code>delayMicroseconds()</code></a>.</p></li>

<li><p>para generar señales PWM: <a href="http://arduino.cc/en/Reference/AnalogWrite"><code>analogWrite()</code></a></p></li>
</ul>

<p>Todas estas funciones de Arduino relacionadas con el tiempo hacen uso de alguno de los temporizadores del microcontrolador <strong>ATmega2560</strong> comprendidos entre el <code>Timer 0</code> y el <code>Timer 2</code>. Si bien son muy cómodas y fáciles de utilizar, en ocasiones pueden no darnos la versatilidad y funcionalidad que deseamos por lo que tendremos que manejar directamente los timers del microcontrolador. Para poder seguir usando estas funciones, en este tutorial se realizarán las explicaciones para el <code>Timer 3</code>, dejando libres así los timers <code>0</code>, <code>1</code> y <code>2</code>.</p>

<p>Por, último, antes de empezar, algunas nociones sobre una de las aplicaciones más usadas y que requerirá de la configuración directa de los timers: la modulación de anchura de pulsos o PWM.</p>

<h1 id="la-modulación-de-anchura-de-pulsos-pulse-width-modulation-pwm">La Modulación de Anchura de Pulsos - Pulse Width Modulation (PWM)</h1>

<p>La <strong>modulación de anchura de pulsos</strong>, en inglés <strong>Pulse Width Modulation (PWM)</strong>, es una técnica que consiste en modificar la anchura de un pulso y que es ampliamente utilizada en convertidores de potencia, control de motores, cargadores de baterías, y un largo etcétera.
Para un periodo determinado, se denomina Duty Cycle al tiempo que el pulso se mantiene activo. De esta forma, el Duty Cycle determinará el valor medio del voltaje entregado a la carga.</p>

<p>La frecuencia de la PWM la determinaremos en función de la carga que estemos alimentando. Así por ejemplo, si la señal PWM la vamos a utilizar para regular la potencia de un elemento calefactor, podría ser una fracción de hercio, para iluminación puede oscilar entre 50 y 150Hz, para el control de algunos servomotores comerciales (típicos para pequeños autómatas y robots como los servomotores Futaba) tendrá que ser de 50Hz y para el control de carga de baterías y control de drivers de motores puede llegar a los 16KHz.</p>

<p>Cuando la señal PWM se emplea para controlar transistores de potencia, habrá que determinar la frecuencia buscando un compromiso entre un funcionamiento fino del dispositivo, el ruido que pueda producir si nos movemos en frecuencias audibles y las perdidas por conmutación de los interruptores de potencia (que aumentarán proporcionalmente al número de veces que tengan que conmutar por segundo).</p>

<p>Una vez determinada la frecuencia de la PWM apropiada para nuestra aplicación, el control de la potencia que queremos entregar lo lograremos controlando el ancho del pulso, el Duty Cycle, el cual podrá venir expresado en términos absolutos (segundos, milisegundos,..) o en porcentaje del Duty Cycle.</p>

<p>Dada la utilidad y frecuente uso de la técnica PWM, la plataforma <a href="http://www.arduino.cc/es/">Arduino</a> ha provisto una sencilla forma de generar este tipo de señales en sus diferentes placas de desarrollo.</p>

<h2 id="pwm-empleando-la-función-analogwrite">PWM empleando la función analogWrite()</h2>

<p>Empleando la función <code>analogWrite(pin, dutyCycle)</code> podemos generar fácilmente una señal PWM en el pin indicado modulando el <code>dutyCycle</code> con un valor comprendido entre <code>0</code> y <code>255</code>.</p>

<ul>
<li><em>Sintaxis</em>

<ul>
<li><code>analogWrite(pin, valor)</code></li>
</ul></li>
<li><em>Parámetros</em>

<ul>
<li><code>pin</code>: número del pin en el que  queremos generar la PWM.</li>
<li><code>valor</code>: duty cycle entre <code>0</code> (siempre apagada) y <code>255</code> (siempre encendida).</li>
</ul></li>
<li><em>Devuelve</em>

<ul>
<li>Nada</li>
</ul></li>
</ul>

<p>Dependiendo de la placa empleado, tendremos más o menos pines sobre los que actuar con esta función. En el caso de las placas <strong>Mega</strong>, disponemos de los pines comprendidos entre el <code>2</code> y el <code>13</code>, así como el <code>44</code> y <code>46</code> (en la <a href="http://arduino.cc/en/Main/ArduinoBoardUno">Arduino Uno</a> sólo disponemos de los pines <code>3</code>, <code>5</code>, <code>6</code>, <code>9</code>, <code>10</code> y <code>11</code>).</p>

<p>Si bien esta es la forma más sencilla de generar una PWM, el problema es que no tenemos ningún control sobre la frecuencia de esta señal siendo, en el caso de la <strong>Mega</strong>, de <code>490Hz</code>.</p>

<p>Un poco más adelante, en este mismo tutorial, veremos como generar señales PWM con mucho mayor control y versatilidad configurando directamente los timers del micro.</p>

<p>Pero antes, vamos a ver algunos conceptos de la arquitectura hardware del microcontrolador que nos serán necesarios para poder manejar los timers.</p>

<h1 id="configurando-directamente-los-temporizadores-del-microcontrolador">Configurando directamente los temporizadores del microcontrolador.</h1>

<p>Como he comentado anteriormente, a grandes rasgos, un Timer/Counter es un periférico interno del microcontrolador que se emplea para contar eventos relacionados con el tiempo (Timer) o eventos externos que aparecen en una de las patillas del micro (Counter).</p>

<p>Este contaje se realiza sobre un registro de <code>8 bits</code> o sobre un registro de <code>16 bits</code> y puede ser consultado, reseteado, comparado, etc. En el caso del <strong>ATmega2560</strong>, la cuenta se lleva sobre los registros llamados <code>TCNTn</code> (siendo <code>n</code> el número del timer).</p>

<p>En caso de configurarlo como contador, la patilla sobre la que se aplican los eventos que provocarán el contaje, no será una patilla cualquiera sino la patilla asociada a la entrada del temporizador correspondiente. A modo de ejemplo, en el caso del <code>Timer 3</code> del <strong>ATmega2560</strong>, la patilla de entrada asociada es la patilla número <code>8</code>, etiquetada como <code>T3</code>.</p>

<p>En caso de configurarlo como temporizador, los eventos que provocarán el contaje serán fracciones de la frecuencia de oscilación del cristal oscilador principal del micro aunque, en algunos casos, puede disponerse de un cristal auxiliar para independizar las frecuencias del micro y del temporizador.</p>

<p>En lo sucesivo, cuando haga referencia a la frecuencia de oscilación lo haré a la del cristal oscilador de la placa <strong>Mega</strong>, que es de <code>16MHz</code>.</p>

<p>Bien, conocida la frecuencia de oscilación de nuestro microcontrolador, lo siguiente será determinar que pines del microcontrolador están relacionados con el funcionamiento del <code>Timer 3</code>. En nuestro caso son los pines <code>OC3A</code>, <code>OC3B</code>, <code>OC3C</code>, <code>T3</code> e <code>ICP3</code> siendo los tres primeros las salidas del timer y los que tenemos accesibles en la placa <strong>ArduinoMega</strong>.</p>

<table>
<thead>
<tr>
<th></th>
<th>Nº de pin en el ATmega2560</th>
<th>Nº de pin en la placa ArduinoMega</th>
</tr>
</thead>

<tbody>
<tr>
<td>OC3A</td>
<td>5</td>
<td>DigitalPin5 (PWM)</td>
</tr>

<tr>
<td>OC3B</td>
<td>6</td>
<td>DigitalPin2 (PWM)</td>
</tr>

<tr>
<td>OC3C</td>
<td>7</td>
<td>DigitalPin3 (PWM)</td>
</tr>
</tbody>
</table>

<p>A continuación pasaríamos a analizar cuales son los registros internos del microcontrolador que nos permiten configurar y trabajar con el <code>Timer 3</code>.</p>

<p>Estos registros son los siguientes:</p>

<table>
<thead>
<tr>
<th>REGISTRO</th>
<th>Nº DE BITS</th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>TCNT3</td>
<td>16</td>
<td>Timer/Counter</td>
</tr>

<tr>
<td>OCR3A</td>
<td>16</td>
<td>Output Compare Register A</td>
</tr>

<tr>
<td>OCR3B</td>
<td>16</td>
<td>Output Compare Register B</td>
</tr>

<tr>
<td>OCR3C</td>
<td>16</td>
<td>Output Compare Register C</td>
</tr>

<tr>
<td>ICR3</td>
<td>16</td>
<td>Input Capture Register</td>
</tr>

<tr>
<td>TCCR3A</td>
<td>8</td>
<td>Timer/Counter Register Control A</td>
</tr>

<tr>
<td>TCCR3B</td>
<td>8</td>
<td>Timer/Counter Register Control B</td>
</tr>

<tr>
<td>TCCR3C</td>
<td>8</td>
<td>Timer/Counter Register Control C</td>
</tr>

<tr>
<td>TIFR3</td>
<td>8</td>
<td>Timer Interrupt Flag Register</td>
</tr>

<tr>
<td>TIMSK3</td>
<td>8</td>
<td>Timer Interrupt Mask Register</td>
</tr>
</tbody>
</table>

<p>A continuación explicaré cual es la función de cada uno de ellos.</p>

<p><strong>TCNT3</strong>: Es un registro de <code>16 bits</code> que almacena el valor del contaje de tiempo. Este valor estará comprendido entre <code>0</code> y <code>2^16=65536</code>.</p>

<p>Vamos a ocuparnos en primer lugar de los registros de control y de las diferentes posibilidades que nos ofrecen en función de los valores que escribamos en sus bits.</p>

<h2 id="registros-de-configuración-tccr3a-tccr3b-y-tccr3c">Registros de configuración <code>TCCR3A</code>, <code>TCCR3B</code> y <code>TCCR3C</code></h2>

<p>Según los valores que escribamos en los bits de estos bits, podremos determinar la frecuencia a la que funciona el timer, su modo de funcionamiento y el comportamiento de los pines de salida asociados al mismo.</p>

<table>
<thead>
<tr>
<th></th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>

<tbody>
<tr>
<td><strong>TCCR3A</strong></td>
<td>COM3A1</td>
<td>COM3A0</td>
<td>COM3B1</td>
<td>COM3B0</td>
<td>COM3C1</td>
<td>COM3C0</td>
<td>WGM31</td>
<td></td>
</tr>

<tr>
<td><strong>TCCR3B</strong></td>
<td>ICNC3</td>
<td>ICES3</td>
<td>-</td>
<td>WGM33</td>
<td>WGM32</td>
<td>CS32</td>
<td>CS31</td>
<td>CS30</td>
</tr>

<tr>
<td><strong>TCCR3C</strong></td>
<td>FOC3A</td>
<td>FOC3B</td>
<td>FOC3C</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>

<h3 id="selección-de-la-frecuencia-de-funcionamiento-del-timer-clock-select">Selección de la frecuencia de funcionamiento del Timer (Clock Select)</h3>

<p>La determinación de si el <code>Timer/Counter 3</code> funciona como contador (contaje de eventos externos en la patilla <code>T3</code>) o como temporizador sincronizado con la frecuencia de oscilación o con una fracción de ella, se realiza a través de los bits <code>CS32</code>, <code>CS31</code> y <code>CS30</code> del registro <code>TCCR3B</code>:</p>

<table>
<thead>
<tr>
<th>CS32</th>
<th>CS31</th>
<th>CS30</th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>Timer/Counter 3 detenido</td>
</tr>

<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>Timer Fclock=Fosc/1 (Sin prescaler)</td>
</tr>

<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>Timer Fclock=Fosc/8 (Prescaler=8)</td>
</tr>

<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>Timer Fclock=Fosc/64 (Prescaler=64)</td>
</tr>

<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>Timer Fclock=Fosc/256 (Prescaler=256)</td>
</tr>

<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>Timer Fclock=Fosc/1024 (Prescaler=1024)</td>
</tr>

<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>Contador de flancos de bajada en el pin T3</td>
</tr>

<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>Contador de flancos de subida en el pin T3</td>
</tr>
</tbody>
</table>

<p>Centrándonos en el funcionamiento en modo temporizador, el prescaler permite decrementar la velocidad de contaje del timer permitiéndonos obtener un mayor rango de tiempos.</p>

<p>Veremos ejemplos de estos tiempos para cada uno de los modos de funcionamiento del Timer/Counter.</p>

<h3 id="modos-de-funcionamiento-del-timer-counter">Modos de funcionamiento del Timer/Counter</h3>

<p>Los diferentes modos de funcionamiento del <code>Timer/Counter 3</code> se determinan a través de los bits <code>WGM33</code>, <code>WGM32</code>, <code>WGM31</code> y <code>WGM30</code> de los registros <code>TCCR3A</code> y <code>TCCR3B</code>.</p>

<table>
<thead>
<tr>
<th>WGM33</th>
<th>WGM32</th>
<th>WGM31</th>
<th>WGM30</th>
<th>MODO</th>
<th>TOP</th>
<th>UPDATE</th>
<th>TOV3</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>Normal Mode</td>
<td>0xFFFF</td>
<td>Inmediato</td>
<td>MAX</td>
</tr>

<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>PWM, Phase Correct 8</td>
<td>0x00FF</td>
<td>TOP</td>
<td>BOTTOM</td>
</tr>

<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>PWM, Phase Correct 9</td>
<td>0x01FF</td>
<td>TOP</td>
<td>BOTTOM</td>
</tr>

<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>PWM, Phase Correct 10</td>
<td>0x03FF</td>
<td>TOP</td>
<td>BOTTOM</td>
</tr>

<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>CTC</td>
<td>OCR3A</td>
<td>Inmediato</td>
<td>MAX</td>
</tr>

<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>Fast PWM, 8 bit</td>
<td>0x00FF</td>
<td>BOTTOM</td>
<td>TOP</td>
</tr>

<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>Fast PWM, 9 bit</td>
<td>0x01FF</td>
<td>BOTTOM</td>
<td>TOP</td>
</tr>

<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>Fast PWM, 10 bit</td>
<td>0x03FF</td>
<td>BOTTOM</td>
<td>TOP</td>
</tr>

<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>PWM Phase &amp; Freq. Correct</td>
<td>ICR3A</td>
<td>BOTTOM</td>
<td>BOTTOM</td>
</tr>

<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>PWM Phase &amp; Freq. Correct</td>
<td>OCR3A</td>
<td>BOTTOM</td>
<td>BOTTOM</td>
</tr>

<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>PWM Phase Correct</td>
<td>ICR3</td>
<td>TOP</td>
<td>BOTTOM</td>
</tr>

<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>PWM Phase Correct</td>
<td>OCR3A</td>
<td>TOP</td>
<td>BOTTOM</td>
</tr>

<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>CTC</td>
<td>ICR3</td>
<td>Inmediato</td>
<td>MAX</td>
</tr>

<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>(Reserved)</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>Fast PWM</td>
<td>ICR3</td>
<td>BOTTOM</td>
<td>TOP</td>
</tr>

<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>Fast PWM</td>
<td>OCR3A</td>
<td>BOTTOM</td>
<td>TOP</td>
</tr>
</tbody>
</table>

<h3 id="comportamiento-de-los-pines-de-salida-oc3a-oc3b-y-oc3c-asociados-al-timer-3">Comportamiento de los pines de salida <code>OC3A</code>, <code>OC3B</code> y <code>OC3C</code> asociados al <code>Timer 3</code>:</h3>

<p>Mediante los bits <code>COM3A1</code>, <code>COM3A0</code>, <code>COM3B1</code>, <code>COM3C1</code> y <code>COM3C0</code> determinaremos el comportamiento de los pines de salida del microcontrolador asociados al <code>Timer 3</code>.</p>

<p>Este timer dispone de tres canales de salida (<code>A</code>, <code>B</code> y <code>C</code>) en las patillas <code>5</code>, <code>6</code> y <code>7</code> (conectadas a las patillas <code>5</code>, <code>2</code> y <code>3</code> respectivamente en la placa <strong>Mega</strong> de <em>Arduino</em>). El comportamiento de estas patillas dependerá del modo de funcionamiento seleccionado y del valor que establezcamos en los bits de configuración de acuerdo a las siguientes tablas.</p>

<p>MODO NO PWM</p>

<table>
<thead>
<tr>
<th>COM3X1</th>
<th>COM3X0</th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>Salidas OC3A/OC3B/OC3C desconectadas</td>
</tr>

<tr>
<td>0</td>
<td>1</td>
<td>Las salidas OC3A/OC3B/OC3C basculan cuando se alcanza la comparación</td>
</tr>

<tr>
<td>1</td>
<td>0</td>
<td>Las salidas OC3A/OC3B/OC3C se ponen a <code>0</code> cuando se alcanza la comparación</td>
</tr>

<tr>
<td>1</td>
<td>1</td>
<td>Las salidas OC3A/OC3B/OC3C se ponen a <code>1</code> cuando se alcanza la comparación</td>
</tr>
</tbody>
</table>

<p>MODO FAST PWM</p>

<table>
<thead>
<tr>
<th>COM3X1</th>
<th>COM3X0</th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>Salidas OC3A/OC3B/OC3C desconectadas</td>
</tr>

<tr>
<td>0</td>
<td>1</td>
<td>La salidas OC3A bascula cuando se alcanza la comparación. OC3B y OC3C desconectadas</td>
</tr>

<tr>
<td>1</td>
<td>0</td>
<td>Las salidas OC3A/OC3B/OC3C se ponen a <code>0</code> cuando se alcanza la comparación y se ponen a <code>1</code> al alcanzar el límite inferior BOTTOM</td>
</tr>

<tr>
<td>1</td>
<td>1</td>
<td>Las salidas OC3A/OC3B/OC3C se ponen a <code>1</code> cuando se alcanza la comparación y se ponen a <code>0</code> al alcanzar el límite inferior BOTTOM</td>
</tr>
</tbody>
</table>

<p>MODO PWM CON CORRECCIÓN DE FASE Y FRECUENCIA</p>

<table>
<thead>
<tr>
<th>COM3X1</th>
<th>COM3X0</th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>Salidas OC3A/OC3B/OC3C desconectadas</td>
</tr>

<tr>
<td>0</td>
<td>1</td>
<td>La salidas OC3A bascula cuando se alcanza la comparación. OC3B y OC3C desconectadas</td>
</tr>

<tr>
<td>1</td>
<td>0</td>
<td>Las salidas OC3A/OC3B/OC3C se ponen a <code>0</code> cuando se alcanza la comparación ASCENDENTE y se ponen a <code>1</code> al alcanzar la comparación descendente</td>
</tr>

<tr>
<td>1</td>
<td>1</td>
<td>Las salidas OC3A/OC3B/OC3C se ponen a <code>1</code> cuando se alcanza la comparación ASCENDENTE y se ponen a <code>0</code> al alcanzar la comparación descendente</td>
</tr>
</tbody>
</table>

<p>Si bien ahora mismo puede parecer un poco complicado, vamos a ver cada uno de los modos de funcionamiento para comprender su funcionamiento.</p>

<h4 id="normal-mode">Normal Mode:</h4>

<p>En este modo de funcionamiento, el registro de <code>16 bits</code> <code>TCNT3</code> se va incrementando a una velocidad determinada por el prescaler.</p>

<p>Cuando alcanza su valor máximo (<code>0xFFFF</code>), el registro se vuelve a poner a <code>0x000</code> automáticamente. A esto se le denomina desbordamiento u overflow.</p>

<p>La pregunta es ahora, ¿que ocurre cuando se desborda el timer? ¿cómo sabremos que se ha desbordado?. Dependiendo de como hayamos configurado los bits <code>COM3A1</code>, <code>COM3A0</code>, <code>COM3B1</code>, <code>COM3C1</code> y <code>COM3C0</code>, este desbordamiento se reflejará en los pines de salida correspondientes (<code>OC3A</code>, <code>OC3B</code> y <code>OC3C</code>) o no de acuerdo a lo indicado en la tabla anterior.</p>

<p>Aunque hayamos decidido que este desbordamiento no se refleje en el pin de salida correspondiente, siempre se señalizará en el bit de <code>Timer Overflow</code> <code>TOV3</code> del registro <code>TIFR3</code> (será necesario ponerlo a cero por software). En caso de tener habilitada la interrupción asociada a este timer mediante el bit <code>Timer 3 Overflow Interrupt</code> del registro <code>TIMSK3</code>, se activaría la interrupción y se produciría el salto del programa al vector <code>TIMER3 OVF</code>.</p>

<p>Y por último, ¿que tiempo tardará el timer en desobordarse?. Bien, este tiempo dependerá de la frecuencia del oscilador al que tengamos conectado nuestro microcontrolador (en nuestro caso <code>16MHz</code>), del prescaler o fracción de esta frecuencia a la cual hayamos configurado el timer y del valor desde el que el timer inicia su cuenta (valor que cargamos en el registro <code>TCNT3</code>).</p>

<pre><code>T=Tosc·PS·(65536-TCNT3)
</code></pre>

<p>Así, los tiempos máximos de desbordamiento los conseguiremos cuando la cuenta comienza en cero, siendo éstos para los diferentes prescalers:</p>

<pre><code>PS=1    -&gt; T=65536·62,5ns·1=4,096ms
PS=8    -&gt; T=65536·62,5ns·8=32,768ms
PS=64   -&gt; T=65536·62,5ns·64=262,144ms
PS=256  -&gt; T=65536·62,5ns·256=1,048s
PS=1024 -&gt; T=65536·62,5ns·1024=4,194s
</code></pre>

<h1 id="ejemplos">Ejemplos</h1>

<p>Vamos a ver algunos ejemplos relacionados con este modo de funcionamiento:</p>

<h2 id="ejemplo-1-ejecución-de-un-programa-controlada-por-tiempo">Ejemplo 1. Ejecución de un programa controlada por tiempo.</h2>

<p>Una de las aplicaciones más interesantes de los timers es la gestión de una interrupción controlada por tiempo de forma que consigamos que una serie de tareas se ejecuten periódicamente teniendo controlado el tiempo de este periodo.</p>

<p>En este ejemplo vamos a realizar un programa que realice una lectura del canal analógico <code>0</code> cada <code>100ms</code> y envía esta lectura por el monitor serie.</p>

<p>Para ello vamos a configurar el <code>Timer 3</code> de forma que se desborde cada 100ms. Este desbordamiento provocará la activación de la interrupción de overflow de este Timer. En este momento, el programa detendrá su ejecución cíclica normal y saltará al vector de interrupción correspondiente, en el cual escribiremos las acciones a realizar de forma periódica.</p>

<p>Para empezar, si miramos los tiempos que podemos conseguir con el microcontrolador <strong>ATmega2560</strong> conectado a un cristal de <code>16MHz</code>, observamos que necesitaremos un prescaler de <code>64</code>, el cual nos permitiría contajes de hasta <code>262ms</code>.</p>

<p>A continuación, calculamos desde que valor deberá iniciar el contaje el <code>Timer 3</code> para que su desbordamiento se produzca a los <code>100ms</code>:</p>

<pre><code>T = 100ms = 62,5ns · 64 · (65536 - TCNT3) ---&gt; TCNT3 = 40536
</code></pre>

<p>Este será el valor de precarga o preset del <code>Timer 3</code>. Cada vez que se desborde, volveremos a cargarle este valor de inicio de contaje para que el siguiente desbordamiento vuelva a producirse a los <code>100ms</code>.</p>

<p>El programa quedaría de la siguiente forma:</p>

<pre><code>/*--------------------------------------------------------------------------------
  Este programa realiza una lectura del canal analógico 0
  cada 100ms y envía esta lectura al terminal serie.
  Cada vez que realiza la lectura y el envió, bascula el
  estado del pin 13 conectado a la placa de Arduino MegaADK
*/

int cont=0;             //Variable que almacena el nº de lecturas

void setup() {
  pinMode(13, OUTPUT);  //EL pin conectado al LED en modo salida
  Serial.begin(9600);   //Monitor serie a 9600 baudios
  TCCR3A = B00000000;   //Modo Normal con salidas desactivadas
  TCCR3B = B00000011;   //Prescaler PS=64
  TCNT3=40536;          //Valor de inicio del Timer 3 para 100ms
  TIMSK3=(1&lt;&lt;TOIE3);    //Interrupción de overflow del Timer 3
  sei();                //Habilitación de las interrupciones
}

void loop(){
   //Aquí iría el cuerpo del programa principal
   //el cual se ejecutaría cíclicamente
}

/*-----------------------------------------------------------
  Rutina de OVERFLOW del TIMER 3
*/

ISR(TIMER3_OVF_vect){
    TCNT3=40536;                        //Recarga del Timer 3
    //bitClear(TIFR3,0);
    Serial.println(cont);               //Envía el nº de lectura
    Serial.println(analogRead(0));      //Envía la lectura del canal 0
    cont=cont++;
    digitalWrite(13, !digitalRead(13)); //Bascula el estado del pin 13
}
</code></pre>

<p>Esta utilización de los temporizadores es muy frecuente y tremendamente útil ya que, cuando deseemos realizar alguna aplicación en la que tengamos que realizar muestreos de determinados sensores (p. ej. medidas de corriente, de tensión, de temperatura,&hellip;), el mantener el periodo de muestreo constante será fundamental para poder realizar después los cálculos necesarios con los valores muestreados.</p>

  </body>
</html>
