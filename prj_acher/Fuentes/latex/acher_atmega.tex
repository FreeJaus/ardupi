\section{Muestra}

Para la gestión de la matriz de LEDs se ha optado por la utilización de un sistema basado en un microcontrolador, junto con diversos drivers que faciliten la programación y la adecuación de las señales. Aunque podría haberse gestionado toda la lógica desde el ordenador, esto habría vuelto el sistema directamente dependiente de éste, lo cual impediría su funcionamiento cuando estuviera apagado. La externalización de la lógica nos permite utilizar el ordenador únicamente para enviar el contenido a mostrar en la matriz, obteniendo un sistema autónomo una vez recibida la información. Si quisiéramos mostrar información preprogramada, en lugar de definir el contenido dinámicamente, el microcontrolador nos da la opción de cargar la información durante el diseño.

Asimilando las ventajas de implementar la lógica de forma externa al ordenador, el microcontrolador se muestra como una de las opciones, entre las cuales también debemos valorar el uso de FPGAs, CPLDs o VLSIs. El diseño con VLSIs y CPLDs resulta excesivamente complejo, debido a la necesidad de efectuar operaciones aritméticas de cierta complejidad y el uso de diversos registros. El diseño se complicaría lo suficiente como para no resultar rentable por el tamaño final del circuito y el número de integrados necesarios. Las FPGAs suplen a la perfección estas necesidades, pero su alimentación resulta más compleja que la de un microcontrolador, y el hecho de disponer de memoria volátil complica la implementación física, al ser necesaria la adición de elementos de memoria para evitar tener que programarlas en cada arranque. Además, ninguna de las opciones anteriores incorpora periféricos específicos para la temporización o la comunicación serie. Estos recursos deberían ser desarrollados por el diseñador. Por estas razones, un sistema microcontrolador se muestra como la mejor opción, al aunar la simplicidad de diseño del circuito y la complejidad de recursos necesaria para esta aplicación.

De entre los muchos microcontroladores disponibles en el mercado, se ha utilizado el modelo Atmega48 de Atmel\cite{atmega48}, con arquitectura AVR\cite{avr}. La elección de este modelo responde a la facilidad de acceso a los recursos para trabajar con él, pues el desarrollador ha tenido a su disposición un kit de desarrollo STK500\cite{stk500} del mismo fabricante. El modelo citado dispone de recursos suficientes para el sistema a desarrollar y permite la evolución de este de cara a añadir funcionalidades en futuras versiones. Además, la arquitectura AVR se diseñó específicamente para la ejecución eficiente de código C compilado, lenguaje utilizado por el desarrollador.

En cualquier caso, y dado que no se hace uso de recursos sólo disponibles en la arquitectura AVR, con la debida adecuación del código podría utilizarse cualquier otro microcontrolador para el cual se disponga de un compilador de C, ya sean los muy extendidos PIC\cite{pic} de Microchip, aquellos compatibles con el 8051\cite{8051} de Intel, u otros muchos disponibles en el mercado.

\input{acher_atmega_esq.tex}
\input{acher_atmega_prog.tex}